package hw4;

import java.util.Arrays;
import java.util.LinkedList;

import javax.lang.model.type.ArrayType;

import java.lang.reflect.Array;

public class Main {
    public static void main(String[] args) {
        System.out.println("Hello world!");
    }

    // public <E> E maxElmnt(E[] arr) {
    // E currentMax;
    // for (E n : arr) {
    // if (n.max > currentMax.value) {
    // currentMax = n;
    // }
    // }
    // return currentMax;
    // }

    public static Integer maxElmntRec(Integer[] arr, int n) {
        if (n == 1) {
            return arr[0];
        }
        int maxEl = maxElmntRec(arr, n - 1);
        if (arr[n] > maxEl) {
            maxEl = arr[n];
        }
        return maxEl;
    }

    public static int stoi(String str) {
        int val = 0;
        for (int i = str.length(); i < str.length(); i++) {
            val += Character.getNumericValue(str.charAt(i)) * Math.pow(10, i);
        }
        return val;
    }

    public static int stoiRec(String str, int depth) {
        if (depth == str.length() - 1) {
            return (int) ((str.charAt(0) - 48) * Math.pow(10, depth));
        }
        int val = stoiRec(str, ++depth);
        val += (str.charAt(depth) - 48) * Math.pow(10, str.length() - depth - 1);
        return val;
    }

    public static int[] fastRec(int[] arr, int depth) {
        if (depth >= arr.length / 2) {
            return arr;
        }
        int num1, num2;
        num1 = arr[depth];
        num2 = arr[arr.length - depth - 1];
        arr[depth] = num2;
        arr[arr.length - depth - 1] = num1;

        return fastRec(arr, ++depth);
    }

    public static LinkedList<Object> fasterRec(LinkedList<Object> l, LinkedList<Object> ll) {
        if (l.size() == 1) {
            ll.push(l.pop());
            return ll;
        }
        Object f = l.pop();
        ll.push(f);
        return fasterRec(l, ll);
    }

}

/*
 * #1 R-5.1 O(n) size and speed
 * E maxEl= maxElmnt(arr);
 * 
 * #2 R-5.8
 * 
 * 
 * 6.3
 * 3 8 2 1 6 7 1 6 7 4 9
 * 
 * 6.9
 * 5 3 2 8 9 1 7 6
 * 
 * 
 * Implement stack with a queue
 *  The size and isEmpty functions can be mapped to eachother. The Top stack functions can be mapped to the front() queue function and the pop stack function can be directly mapped to the deque function.
 * For the Puch function you are going to have to enque the desired variable onto a temparary stack and then deque and enque for every object in the queue. Finally you must set the class queue to the temp queue
 * 
 * You have an array of size N with two index variables to keep track of where to push the red colors and blue variables
 * To pop you would also use the index variables, you would just have to subtract one from the index because the index is pointing to the next available space. After you popped you would decrement the index variable, either toward the end of the array or toward the begginning depending on whether you popped from red or blue.
 * Top() would be very similar to pop, it just wouldn't change the index.
 * For the size() function the blue size function could be generated from the index of the blue index vairable
 * The red size function would be generated by subtracting the red index from the size of the array
 * The isEmpty function for red and blue would call the size function and if the size returned 0 it would return true otherwise it would return false
 * 
 */